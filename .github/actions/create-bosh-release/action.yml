name: 'Create BOSH Release'
description: 'Create a BOSH release tarball (final or dev) with vendored golang-1-linux and a rootfs blob'

inputs:
  stack:
    description: 'Stack name (e.g., {your-cflinuxfs-version})'
    required: true
  bucket_name:
    description: 'S3 bucket name'
    required: true
  version:
    description: 'Version number (e.g., 1.0.0 or 1.0.0-rc.1)'
    required: true
  release_name:
    description: 'BOSH release name (e.g., {your-cflinuxfs-version})'
    required: true
  release_repo:
    description: 'GitHub org/repo for the BOSH release'
    required: true
  release_deploy_key:
    description: 'SSH deploy key for release repo'
    required: true
  bosh_cli_version:
    description: 'Version of bosh-cli to install'
    required: false
    default: "7.9.11"
  go_version:
    description: 'Go version to vendor as a blob under golang-1-linux (e.g., 1.24.6)'
    required: true
  golang_release_ref:
    description: 'Git ref (tag/branch/commit) of bosh-package-golang-release to vendor from'
    required: false
    default: "main"
  release_dir:
    description: 'Path to the BOSH release repository'
    default: "release"
    required: false
  final:
    description: 'Whether to create a final release (true) or a dev release (false)'
    required: false
    default: "true"

outputs:
  release_tarball:
    description: 'Path to the generated BOSH release tarball'
    value: ${{ steps.set-output.outputs.release_tarball }}

runs:
  using: "composite"
  steps:
    - name: Install prerequisites
      shell: bash
      run: |
        set -euo pipefail
        sudo apt-get update -y
        sudo apt-get install -y curl wget git jq

    - name: Checkout Release repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.release_repo }}
        ref: main
        path: ${{ inputs.release_dir }}
        ssh-key: ${{ inputs.release_deploy_key }}

    - name: Checkout bosh-package-golang-release
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/bosh-package-golang-release
        ref: ${{ inputs.golang_release_ref }}
        path: bosh-package-golang-release

    - name: Cache BOSH/BBL tools
      id: cache-tools
      uses: actions/cache@v4
      with:
        path: |
          /usr/local/bin/bbl
          /usr/local/bin/bosh
          /usr/local/bin/terraform
        key: ${{ runner.os }}-bbl-tools-v1  
        restore-keys: ${{ runner.os }}-bbl-tools-

    - name: Install bosh CLI
      if: steps.cache-tools.outputs.cache-hit != 'true'
      shell: bash
      run: |
        VERSION="${{ inputs.bosh_cli_version }}"
        wget -O /tmp/bosh "https://github.com/cloudfoundry/bosh-cli/releases/download/v${VERSION}/bosh-cli-${VERSION}-linux-amd64"
        chmod +x /tmp/bosh
        sudo mv /tmp/bosh /usr/local/bin/bosh
        bosh --version

    - name: Configure BOSH blobstore
      shell: bash
      run: |
        set -euo pipefail
        
        mkdir -p ${{ inputs.release_dir }}/config

        echo "=== BOSH Config Debug (keys masked) ==="
        echo "AWS_ACCESS_KEY_ID length (expected ~20): ${#AWS_ACCESS_KEY_ID}"
        echo "AWS_SECRET_ACCESS_KEY length (expected ~40): ${#AWS_SECRET_ACCESS_KEY}"
        echo "AWS_SESSION_TOKEN present: ${AWS_SESSION_TOKEN:+yes (length ${#AWS_SESSION_TOKEN})}"
        echo "AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION"
        
        if [[ -n "$AWS_ACCESS_KEY_ID" ]]; then
          echo "AWS_ACCESS_KEY_ID starts with: ${AWS_ACCESS_KEY_ID:0:4}***"
        else
          echo "ERROR: AWS_ACCESS_KEY_ID is empty - OIDC not inherited"
          exit 1
        fi

        cat > ${{ inputs.release_dir }}/config/private.yml <<EOF
        ---
        blobstore:
          provider: s3
          options:
            bucket_name: ${{ inputs.bucket_name }}
            access_key_id: $AWS_ACCESS_KEY_ID
            secret_access_key: $AWS_SECRET_ACCESS_KEY
            session_token: $AWS_SESSION_TOKEN
            region: $AWS_DEFAULT_REGION
            endpoint: https://s3.$AWS_DEFAULT_REGION.amazonaws.com
        EOF

        echo "=== Private.yml Created (masked, verify expansion) ==="
        cat ${{ inputs.release_dir }}/config/private.yml | sed 's/access_key_id: [^ ]*/access_key_id: MASKED/g' | sed 's/secret_access_key: [^ ]*/secret_access_key: MASKED/g' | sed 's/session_token: [^ ]*/session_token: MASKED/g'
        
        # ✅ Test if expansion worked (check if key is MASKED, not literal $AWS...)
        if grep -q "\$AWS_ACCESS_KEY_ID" ${{ inputs.release_dir }}/config/private.yml; then
          echo "ERROR: Variable not expanded - private.yml has literal \$AWS_ACCESS_KEY_ID"
          exit 1
        fi
        echo "✅ Expansion success - keys populated (not literal variables)"

        echo "BOSH config ready - proceed to build"

    - name: Build BOSH release
      id: build
      shell: bash
      run: |
        set -euo pipefail
        STACK="${{ inputs.stack }}"
        VERSION="${{ inputs.version }}"
        GO_VERSION="${{ inputs.go_version }}"
        FINAL="${{ inputs.final }}"

        cd "${{ inputs.release_dir }}"

        bosh vendor-package golang-1-linux ../bosh-package-golang-release

        GO_BLOB_DIR="blobs/golang-1-linux"
        GO_BLOB_FILE="go${GO_VERSION}.linux-amd64.tar.gz"
        mkdir -p "${GO_BLOB_DIR}"
        if [[ ! -f "${GO_BLOB_DIR}/${GO_BLOB_FILE}" ]]; then
          echo "Downloading Go ${GO_VERSION} blob..."
          curl -L "https://go.dev/dl/${GO_BLOB_FILE}" -o "${GO_BLOB_DIR}/${GO_BLOB_FILE}"
          bosh add-blob "${GO_BLOB_DIR}/${GO_BLOB_FILE}" "golang-1-linux/${GO_BLOB_FILE}"
        fi

        mkdir -p blobs/rootfs
        bosh remove-blob rootfs/${STACK}-*.tar.gz || true
        cp ../rootfs-artifacts/${STACK}-${VERSION}.tar.gz blobs/rootfs/${STACK}-${VERSION}.tar.gz
        bosh add-blob blobs/rootfs/${STACK}-${VERSION}.tar.gz rootfs/${STACK}-${VERSION}.tar.gz

        bosh sync-blobs

        mkdir -p ../rootfs-artifacts
        OUTPUT="../rootfs-artifacts/${STACK}-release-${VERSION}.tgz"

        if [[ "$FINAL" == "true" ]]; then
          echo "Creating FINAL release..."
          bosh create-release --final \
            --name "${{ inputs.release_name }}" \
            --version "${VERSION}" \
            --tarball "$OUTPUT" \
            --force
        else
          echo "Creating DEV (non-final) release..."
          bosh create-release \
            --name "${{ inputs.release_name }}" \
            --version "${VERSION}" \
            --tarball "$OUTPUT" \
            --force
        fi

        echo "release_tarball=$OUTPUT" >> $GITHUB_OUTPUT

    - name: Set output
      id: set-output
      shell: bash
      run: |
        echo "release_tarball=${{ steps.build.outputs.release_tarball }}" >> $GITHUB_OUTPUT
