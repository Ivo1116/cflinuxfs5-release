# .github/actions/setup-cloudflare-dns/action.yml

name: 'Setup Cloudflare DNS for CF Environment'
description: 'Extract IPs from BOSH vars YAML files in BBL state repo, clean up duplicate DNS records in Cloudflare, and create/update DNS records'

inputs:
  env_name:
    description: 'Environment name (used for vars file paths in BBL state repo)'
    required: true
    default: 'cflinuxfs5'
  bbl_state_repo:
    description: 'BBL state repository (cloned for vars files)'
    required: true
    default: 'ivo1116/buildpacks-envs'  # Default from main workflow
  bbl_state_branch:
    description: 'BBL state branch'
    required: true
    default: 'main'
  system_domain:
    description: 'System domain (e.g., sisle.org)'
    required: true
    default: 'sisle.org'

outputs:
  success:
    description: 'Whether DNS setup succeeded'
    value: ${{ steps.setup-dns.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Install dependencies (yq and jq)
      shell: bash
      run: |
        # Install yq
        sudo snap install yq
        # Install jq (usually available, but ensure)
        sudo apt-get update
        sudo apt-get install -y jq

    - name: Checkout BBL state repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.bbl_state_repo }}
        ref: ${{ inputs.bbl_state_branch }}
        ssh-key: ${{ env.BBL_STATE_DEPLOY_KEY }}
        path: bbl-state
        persist-credentials: false

    - name: Extract IPs from YAML files
      id: extract-ips
      shell: bash
      run: |
        # Vars files are in cloned BBL state repo at bbl-state/{env_name}/vars/
        ENV_NAME="${{ inputs.env_name }}"
        JUMBOX_VARS="bbl-state/${ENV_NAME}/vars/jumpbox-vars-file.yml"
        DIRECTOR_VARS="bbl-state/${ENV_NAME}/vars/director-vars-file.yml"
        SYS_SUBDOMAIN="sys"  # Fixed as per standard CF

        if [[ ! -f "$JUMBOX_VARS" || ! -f "$DIRECTOR_VARS" ]]; then
          echo "Error: YAML files not found at $JUMBOX_VARS and $DIRECTOR_VARS"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        ROUTER_LB_IP=$(yq eval '.router_lb_ip' "$JUMBOX_VARS")
        SSH_PROXY_LB_IP=$(yq eval '.ssh_proxy_lb_ip' "$JUMBOX_VARS")
        TCP_ROUTER_LB_IP=$(yq eval '.tcp_router_lb_ip' "$JUMBOX_VARS")
        WS_LB_IP=$(yq eval '.ws_lb_ip' "$JUMBOX_VARS")

        # Validate consistency with director vars (optional)
        if [[ "$(yq eval '.router_lb_ip' "$DIRECTOR_VARS")" != "$ROUTER_LB_IP" ]]; then
          echo "Warning: router_lb_ip mismatch between files."
        fi

        # Output IPs as step outputs and env for next steps
        echo "router_lb_ip=$ROUTER_LB_IP" >> $GITHUB_OUTPUT
        echo "ssh_proxy_lb_ip=$SSH_PROXY_LB_IP" >> $GITHUB_OUTPUT
        echo "tcp_router_lb_ip=$TCP_ROUTER_LB_IP" >> $GITHUB_OUTPUT
        echo "ws_lb_ip=$WS_LB_IP" >> $GITHUB_OUTPUT

        # Export as env for the next step
        echo "ROUTER_LB_IP=$ROUTER_LB_IP" >> $GITHUB_ENV
        echo "SSH_PROXY_LB_IP=$SSH_PROXY_LB_IP" >> $GITHUB_ENV
        echo "TCP_ROUTER_LB_IP=$TCP_ROUTER_LB_IP" >> $GITHUB_ENV
        echo "WS_LB_IP=$WS_LB_IP" >> $GITHUB_ENV
        echo "DOMAIN=${{ inputs.system_domain }}" >> $GITHUB_ENV
        echo "SYS_SUBDOMAIN=$SYS_SUBDOMAIN" >> $GITHUB_ENV

        echo "Extracted IPs:"
        echo "  router_lb_ip: $ROUTER_LB_IP"
        echo "  ssh_proxy_lb_ip: $SSH_PROXY_LB_IP"
        echo "  tcp_router_lb_ip: $TCP_ROUTER_LB_IP"
        echo "  ws_lb_ip: $WS_LB_IP"

    - name: Validate Cloudflare secrets
      shell: bash
      run: |
        if [[ -z "$CLOUDFLARE_API_TOKEN" || -z "$CLOUDFLARE_ZONE_ID" ]]; then
          echo "Error: CLOUDFLARE_API_TOKEN or CLOUDFLARE_ZONE_ID not set."
          exit 1
        fi
        echo "Cloudflare credentials validated."

    - name: Create or Update DNS Records (with Duplicate Cleanup)
      id: setup-dns
      shell: bash
      run: |
        # Function to delete all existing records for a given name and type (handles duplicates)
        delete_all_records_for_name() {
          local name="$1"
          local record_type="$2"

          echo "Checking for existing records for $name ($record_type)..."
          local existing_records
          existing_records=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?type=$record_type&name=$name" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          # Get all non-null IDs into an array (avoids pipeline subshell issues)
          local record_ids
          mapfile -t record_ids < <(echo "$existing_records" | jq -r '.result[]? | select(.id != null) | .id // empty' | grep -v '^$')

          local num_records=${#record_ids[@]}
          if [[ $num_records -eq 0 ]]; then
            echo "No existing records found for $name."
            return 0
          fi

          local count=0
          for record_id in "${record_ids[@]}"; do
            if [[ -n "$record_id" && "$record_id" != "null" ]]; then
              echo "Deleting existing record ID: $record_id for $name"
              local delete_response
              delete_response=$(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$record_id" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json")

              if echo "$delete_response" | jq -e '.success' >/dev/null 2>&1; then
                echo "Successfully deleted record: $record_id"
                count=$((count + 1))
              else
                echo "Failed to delete $record_id: $(echo "$delete_response" | jq -r '.errors // "Unknown error"' 2>/dev/null || echo "Invalid JSON response")"
                return 1
              fi
            fi
          done

          echo "Deleted $count out of $num_records records for $name."
        }

        # Function to create a new DNS record
        create_record() {
          local name="$1"
          local ip="$2"
          local record_type="A"
          local proxied=false  # DNS only (no proxy)

          echo "Creating new record: $name -> $ip"

          # Generate clean JSON payload using jq (handles quoting, wildcards, booleans safely)
          local json_payload
          json_payload=$(jq -n \
            --arg type "$record_type" \
            --arg name "$name" \
            --arg content "$ip" \
            --argjson ttl 1 \
            --argjson proxied false \
            '{type: $type, name: $name, content: $content, ttl: $ttl, proxied: $proxied}')

          echo "Generated JSON payload (for debug): $json_payload"

          local response
          response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$json_payload")

          if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            echo "Successfully created: $name"
            return 0
          else
            echo "Failed to create $name. Response: $(echo "$response" | jq -r '.errors[]? | .message // "Unknown error"' 2>/dev/null || echo "Invalid JSON response")"
            return 1
          fi
        }

        # Records to configure (delete existing, then create)
        local_records=(
          "* $ROUTER_LB_IP"  # Wildcard app domain (*.sisle.org)
          "$DOMAIN $ROUTER_LB_IP"  # Apex domain (sisle.org)
          "*.$SYS_SUBDOMAIN.$DOMAIN $ROUTER_LB_IP"  # Wildcard system domain (*.sys.sisle.org)
          "doppler.$SYS_SUBDOMAIN.$DOMAIN $WS_LB_IP"
          "loggregator.$SYS_SUBDOMAIN.$DOMAIN $WS_LB_IP"
          "ssh.$SYS_SUBDOMAIN.$DOMAIN $SSH_PROXY_LB_IP"
          "tcp.$SYS_SUBDOMAIN.$DOMAIN $TCP_ROUTER_LB_IP"
        )

        all_success=true
        for record in "${local_records[@]}"; do
          IFS=' ' read -r name ip <<< "$record"
          echo "Processing record: $name"
          if ! delete_all_records_for_name "$name" "A"; then
            echo "Deletion failed for $name, skipping creation."
            all_success=false
            continue
          fi
          sleep 1  # Brief delay for API propagation (optional)
          echo "Deletion complete for $name, proceeding to create."
          if ! create_record "$name" "$ip"; then
            echo "Creation failed for $name."
            all_success=false
          fi
          echo "---"  # Separator for logs
        done

        if [[ $all_success == true ]]; then
          echo "All DNS records cleaned up and configured successfully!"
          echo "success=true" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "One or more DNS operations failed."
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
